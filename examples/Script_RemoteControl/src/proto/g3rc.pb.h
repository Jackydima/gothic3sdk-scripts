// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: g3rc.proto

#ifndef PROTOBUF_g3rc_2eproto__INCLUDED
#define PROTOBUF_g3rc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace g3rc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_g3rc_2eproto();
void protobuf_AssignDesc_g3rc_2eproto();
void protobuf_ShutdownFile_g3rc_2eproto();

class RequestContainer;
class ResponseContainer;
class HearbeatRequest;
class EntityRequest;
class GotoRequest;
class SpawnRequest;
class PropertyRequest;
class HearbeatResponse;
class VoidResponse;
class EntityResponse;
class PropertyResponse;
class Position;
class Vector;
class EulerAngles;
class PropertyIdentifier;
class PropertySerialized;

enum ResponseContainer_Status {
  ResponseContainer_Status_FAILED = 0,
  ResponseContainer_Status_SUCCESSFUL = 1
};
bool ResponseContainer_Status_IsValid(int value);
const ResponseContainer_Status ResponseContainer_Status_Status_MIN = ResponseContainer_Status_FAILED;
const ResponseContainer_Status ResponseContainer_Status_Status_MAX = ResponseContainer_Status_SUCCESSFUL;
const int ResponseContainer_Status_Status_ARRAYSIZE = ResponseContainer_Status_Status_MAX + 1;

enum HearbeatResponse_Status {
  HearbeatResponse_Status_MENU = 0,
  HearbeatResponse_Status_LOADING = 1,
  HearbeatResponse_Status_INGAME = 2
};
bool HearbeatResponse_Status_IsValid(int value);
const HearbeatResponse_Status HearbeatResponse_Status_Status_MIN = HearbeatResponse_Status_MENU;
const HearbeatResponse_Status HearbeatResponse_Status_Status_MAX = HearbeatResponse_Status_INGAME;
const int HearbeatResponse_Status_Status_ARRAYSIZE = HearbeatResponse_Status_Status_MAX + 1;

// ===================================================================

class RequestContainer : public ::google::protobuf::MessageLite {
 public:
  RequestContainer();
  virtual ~RequestContainer();

  RequestContainer(const RequestContainer& from);

  inline RequestContainer& operator=(const RequestContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestContainer& default_instance();

  enum RequestCase {
    kHeartbeatRequest = 2,
    kEntityRequest = 3,
    kGotoRequest = 4,
    kSpawnRequest = 5,
    kPropertyRequest = 6,
    REQUEST_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestContainer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestContainer* other);

  // implements Message ----------------------------------------------

  RequestContainer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestContainer& from);
  void MergeFrom(const RequestContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 request_number = 1;
  inline bool has_request_number() const;
  inline void clear_request_number();
  static const int kRequestNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 request_number() const;
  inline void set_request_number(::google::protobuf::uint32 value);

  // optional .g3rc.HearbeatRequest heartbeat_request = 2;
  inline bool has_heartbeat_request() const;
  inline void clear_heartbeat_request();
  static const int kHeartbeatRequestFieldNumber = 2;
  inline const ::g3rc::HearbeatRequest& heartbeat_request() const;
  inline ::g3rc::HearbeatRequest* mutable_heartbeat_request();
  inline ::g3rc::HearbeatRequest* release_heartbeat_request();
  inline void set_allocated_heartbeat_request(::g3rc::HearbeatRequest* heartbeat_request);

  // optional .g3rc.EntityRequest entity_request = 3;
  inline bool has_entity_request() const;
  inline void clear_entity_request();
  static const int kEntityRequestFieldNumber = 3;
  inline const ::g3rc::EntityRequest& entity_request() const;
  inline ::g3rc::EntityRequest* mutable_entity_request();
  inline ::g3rc::EntityRequest* release_entity_request();
  inline void set_allocated_entity_request(::g3rc::EntityRequest* entity_request);

  // optional .g3rc.GotoRequest goto_request = 4;
  inline bool has_goto_request() const;
  inline void clear_goto_request();
  static const int kGotoRequestFieldNumber = 4;
  inline const ::g3rc::GotoRequest& goto_request() const;
  inline ::g3rc::GotoRequest* mutable_goto_request();
  inline ::g3rc::GotoRequest* release_goto_request();
  inline void set_allocated_goto_request(::g3rc::GotoRequest* goto_request);

  // optional .g3rc.SpawnRequest spawn_request = 5;
  inline bool has_spawn_request() const;
  inline void clear_spawn_request();
  static const int kSpawnRequestFieldNumber = 5;
  inline const ::g3rc::SpawnRequest& spawn_request() const;
  inline ::g3rc::SpawnRequest* mutable_spawn_request();
  inline ::g3rc::SpawnRequest* release_spawn_request();
  inline void set_allocated_spawn_request(::g3rc::SpawnRequest* spawn_request);

  // optional .g3rc.PropertyRequest property_request = 6;
  inline bool has_property_request() const;
  inline void clear_property_request();
  static const int kPropertyRequestFieldNumber = 6;
  inline const ::g3rc::PropertyRequest& property_request() const;
  inline ::g3rc::PropertyRequest* mutable_property_request();
  inline ::g3rc::PropertyRequest* release_property_request();
  inline void set_allocated_property_request(::g3rc::PropertyRequest* property_request);

  inline RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:g3rc.RequestContainer)
 private:
  inline void set_has_request_number();
  inline void clear_has_request_number();
  inline void set_has_heartbeat_request();
  inline void set_has_entity_request();
  inline void set_has_goto_request();
  inline void set_has_spawn_request();
  inline void set_has_property_request();

  inline bool has_request();
  void clear_request();
  inline void clear_has_request();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 request_number_;
  union RequestUnion {
    ::g3rc::HearbeatRequest* heartbeat_request_;
    ::g3rc::EntityRequest* entity_request_;
    ::g3rc::GotoRequest* goto_request_;
    ::g3rc::SpawnRequest* spawn_request_;
    ::g3rc::PropertyRequest* property_request_;
  } request_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static RequestContainer* default_instance_;
};
// -------------------------------------------------------------------

class ResponseContainer : public ::google::protobuf::MessageLite {
 public:
  ResponseContainer();
  virtual ~ResponseContainer();

  ResponseContainer(const ResponseContainer& from);

  inline ResponseContainer& operator=(const ResponseContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ResponseContainer& default_instance();

  enum ResponseCase {
    kHeartbeatResponse = 4,
    kEntityResponse = 5,
    kVoidResponse = 6,
    kPropertyResponse = 7,
    RESPONSE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseContainer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseContainer* other);

  // implements Message ----------------------------------------------

  ResponseContainer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseContainer& from);
  void MergeFrom(const ResponseContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ResponseContainer_Status Status;
  static const Status FAILED = ResponseContainer_Status_FAILED;
  static const Status SUCCESSFUL = ResponseContainer_Status_SUCCESSFUL;
  static inline bool Status_IsValid(int value) {
    return ResponseContainer_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ResponseContainer_Status_Status_MIN;
  static const Status Status_MAX =
    ResponseContainer_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ResponseContainer_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 request_number = 1;
  inline bool has_request_number() const;
  inline void clear_request_number();
  static const int kRequestNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 request_number() const;
  inline void set_request_number(::google::protobuf::uint32 value);

  // required .g3rc.ResponseContainer.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::g3rc::ResponseContainer_Status status() const;
  inline void set_status(::g3rc::ResponseContainer_Status value);

  // optional string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .g3rc.HearbeatResponse heartbeat_response = 4;
  inline bool has_heartbeat_response() const;
  inline void clear_heartbeat_response();
  static const int kHeartbeatResponseFieldNumber = 4;
  inline const ::g3rc::HearbeatResponse& heartbeat_response() const;
  inline ::g3rc::HearbeatResponse* mutable_heartbeat_response();
  inline ::g3rc::HearbeatResponse* release_heartbeat_response();
  inline void set_allocated_heartbeat_response(::g3rc::HearbeatResponse* heartbeat_response);

  // optional .g3rc.EntityResponse entity_response = 5;
  inline bool has_entity_response() const;
  inline void clear_entity_response();
  static const int kEntityResponseFieldNumber = 5;
  inline const ::g3rc::EntityResponse& entity_response() const;
  inline ::g3rc::EntityResponse* mutable_entity_response();
  inline ::g3rc::EntityResponse* release_entity_response();
  inline void set_allocated_entity_response(::g3rc::EntityResponse* entity_response);

  // optional .g3rc.VoidResponse void_response = 6;
  inline bool has_void_response() const;
  inline void clear_void_response();
  static const int kVoidResponseFieldNumber = 6;
  inline const ::g3rc::VoidResponse& void_response() const;
  inline ::g3rc::VoidResponse* mutable_void_response();
  inline ::g3rc::VoidResponse* release_void_response();
  inline void set_allocated_void_response(::g3rc::VoidResponse* void_response);

  // optional .g3rc.PropertyResponse property_response = 7;
  inline bool has_property_response() const;
  inline void clear_property_response();
  static const int kPropertyResponseFieldNumber = 7;
  inline const ::g3rc::PropertyResponse& property_response() const;
  inline ::g3rc::PropertyResponse* mutable_property_response();
  inline ::g3rc::PropertyResponse* release_property_response();
  inline void set_allocated_property_response(::g3rc::PropertyResponse* property_response);

  inline ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:g3rc.ResponseContainer)
 private:
  inline void set_has_request_number();
  inline void clear_has_request_number();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_heartbeat_response();
  inline void set_has_entity_response();
  inline void set_has_void_response();
  inline void set_has_property_response();

  inline bool has_response();
  void clear_response();
  inline void clear_has_response();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 request_number_;
  int status_;
  ::std::string* message_;
  union ResponseUnion {
    ::g3rc::HearbeatResponse* heartbeat_response_;
    ::g3rc::EntityResponse* entity_response_;
    ::g3rc::VoidResponse* void_response_;
    ::g3rc::PropertyResponse* property_response_;
  } response_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static ResponseContainer* default_instance_;
};
// -------------------------------------------------------------------

class HearbeatRequest : public ::google::protobuf::MessageLite {
 public:
  HearbeatRequest();
  virtual ~HearbeatRequest();

  HearbeatRequest(const HearbeatRequest& from);

  inline HearbeatRequest& operator=(const HearbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HearbeatRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HearbeatRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HearbeatRequest* other);

  // implements Message ----------------------------------------------

  HearbeatRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HearbeatRequest& from);
  void MergeFrom(const HearbeatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g3rc.HearbeatRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static HearbeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class EntityRequest : public ::google::protobuf::MessageLite {
 public:
  EntityRequest();
  virtual ~EntityRequest();

  EntityRequest(const EntityRequest& from);

  inline EntityRequest& operator=(const EntityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EntityRequest& default_instance();

  enum IdentifierCase {
    kName = 1,
    kGuid = 2,
    kFocus = 3,
    kEditor = 6,
    IDENTIFIER_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EntityRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EntityRequest* other);

  // implements Message ----------------------------------------------

  EntityRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EntityRequest& from);
  void MergeFrom(const EntityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string guid = 2;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 2;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // optional bool focus = 3;
  inline bool has_focus() const;
  inline void clear_focus();
  static const int kFocusFieldNumber = 3;
  inline bool focus() const;
  inline void set_focus(bool value);

  // optional bool editor = 6;
  inline bool has_editor() const;
  inline void clear_editor();
  static const int kEditorFieldNumber = 6;
  inline bool editor() const;
  inline void set_editor(bool value);

  // optional .g3rc.Position moveto = 4;
  inline bool has_moveto() const;
  inline void clear_moveto();
  static const int kMovetoFieldNumber = 4;
  inline const ::g3rc::Position& moveto() const;
  inline ::g3rc::Position* mutable_moveto();
  inline ::g3rc::Position* release_moveto();
  inline void set_allocated_moveto(::g3rc::Position* moveto);

  // optional bool put_to_ground = 5;
  inline bool has_put_to_ground() const;
  inline void clear_put_to_ground();
  static const int kPutToGroundFieldNumber = 5;
  inline bool put_to_ground() const;
  inline void set_put_to_ground(bool value);

  inline IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:g3rc.EntityRequest)
 private:
  inline void set_has_name();
  inline void set_has_guid();
  inline void set_has_focus();
  inline void set_has_editor();
  inline void set_has_moveto();
  inline void clear_has_moveto();
  inline void set_has_put_to_ground();
  inline void clear_has_put_to_ground();

  inline bool has_identifier();
  void clear_identifier();
  inline void clear_has_identifier();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::g3rc::Position* moveto_;
  bool put_to_ground_;
  union IdentifierUnion {
    ::std::string* name_;
    ::std::string* guid_;
    bool focus_;
    bool editor_;
  } identifier_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static EntityRequest* default_instance_;
};
// -------------------------------------------------------------------

class GotoRequest : public ::google::protobuf::MessageLite {
 public:
  GotoRequest();
  virtual ~GotoRequest();

  GotoRequest(const GotoRequest& from);

  inline GotoRequest& operator=(const GotoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GotoRequest& default_instance();

  enum IdentifierCase {
    kName = 1,
    kGuid = 2,
    kPosition = 3,
    IDENTIFIER_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GotoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GotoRequest* other);

  // implements Message ----------------------------------------------

  GotoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GotoRequest& from);
  void MergeFrom(const GotoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string guid = 2;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 2;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // optional .g3rc.Vector position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::g3rc::Vector& position() const;
  inline ::g3rc::Vector* mutable_position();
  inline ::g3rc::Vector* release_position();
  inline void set_allocated_position(::g3rc::Vector* position);

  // optional bool put_to_ground = 4;
  inline bool has_put_to_ground() const;
  inline void clear_put_to_ground();
  static const int kPutToGroundFieldNumber = 4;
  inline bool put_to_ground() const;
  inline void set_put_to_ground(bool value);

  inline IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:g3rc.GotoRequest)
 private:
  inline void set_has_name();
  inline void set_has_guid();
  inline void set_has_position();
  inline void set_has_put_to_ground();
  inline void clear_has_put_to_ground();

  inline bool has_identifier();
  void clear_identifier();
  inline void clear_has_identifier();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool put_to_ground_;
  union IdentifierUnion {
    ::std::string* name_;
    ::std::string* guid_;
    ::g3rc::Vector* position_;
  } identifier_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static GotoRequest* default_instance_;
};
// -------------------------------------------------------------------

class SpawnRequest : public ::google::protobuf::MessageLite {
 public:
  SpawnRequest();
  virtual ~SpawnRequest();

  SpawnRequest(const SpawnRequest& from);

  inline SpawnRequest& operator=(const SpawnRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SpawnRequest& default_instance();

  enum IdentifierCase {
    kTemplateName = 1,
    kTemplateGuid = 2,
    IDENTIFIER_NOT_SET = 0,
  };

  enum LocationCase {
    kEntityName = 3,
    kEntityGuid = 4,
    kPosition = 5,
    LOCATION_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SpawnRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SpawnRequest* other);

  // implements Message ----------------------------------------------

  SpawnRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpawnRequest& from);
  void MergeFrom(const SpawnRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string template_name = 1;
  inline bool has_template_name() const;
  inline void clear_template_name();
  static const int kTemplateNameFieldNumber = 1;
  inline const ::std::string& template_name() const;
  inline void set_template_name(const ::std::string& value);
  inline void set_template_name(const char* value);
  inline void set_template_name(const char* value, size_t size);
  inline ::std::string* mutable_template_name();
  inline ::std::string* release_template_name();
  inline void set_allocated_template_name(::std::string* template_name);

  // optional string template_guid = 2;
  inline bool has_template_guid() const;
  inline void clear_template_guid();
  static const int kTemplateGuidFieldNumber = 2;
  inline const ::std::string& template_guid() const;
  inline void set_template_guid(const ::std::string& value);
  inline void set_template_guid(const char* value);
  inline void set_template_guid(const char* value, size_t size);
  inline ::std::string* mutable_template_guid();
  inline ::std::string* release_template_guid();
  inline void set_allocated_template_guid(::std::string* template_guid);

  // optional string entity_name = 3;
  inline bool has_entity_name() const;
  inline void clear_entity_name();
  static const int kEntityNameFieldNumber = 3;
  inline const ::std::string& entity_name() const;
  inline void set_entity_name(const ::std::string& value);
  inline void set_entity_name(const char* value);
  inline void set_entity_name(const char* value, size_t size);
  inline ::std::string* mutable_entity_name();
  inline ::std::string* release_entity_name();
  inline void set_allocated_entity_name(::std::string* entity_name);

  // optional string entity_guid = 4;
  inline bool has_entity_guid() const;
  inline void clear_entity_guid();
  static const int kEntityGuidFieldNumber = 4;
  inline const ::std::string& entity_guid() const;
  inline void set_entity_guid(const ::std::string& value);
  inline void set_entity_guid(const char* value);
  inline void set_entity_guid(const char* value, size_t size);
  inline ::std::string* mutable_entity_guid();
  inline ::std::string* release_entity_guid();
  inline void set_allocated_entity_guid(::std::string* entity_guid);

  // optional .g3rc.Vector position = 5;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 5;
  inline const ::g3rc::Vector& position() const;
  inline ::g3rc::Vector* mutable_position();
  inline ::g3rc::Vector* release_position();
  inline void set_allocated_position(::g3rc::Vector* position);

  inline IdentifierCase identifier_case() const;
  inline LocationCase location_case() const;
  // @@protoc_insertion_point(class_scope:g3rc.SpawnRequest)
 private:
  inline void set_has_template_name();
  inline void set_has_template_guid();
  inline void set_has_entity_name();
  inline void set_has_entity_guid();
  inline void set_has_position();

  inline bool has_identifier();
  void clear_identifier();
  inline void clear_has_identifier();

  inline bool has_location();
  void clear_location();
  inline void clear_has_location();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union IdentifierUnion {
    ::std::string* template_name_;
    ::std::string* template_guid_;
  } identifier_;
  union LocationUnion {
    ::std::string* entity_name_;
    ::std::string* entity_guid_;
    ::g3rc::Vector* position_;
  } location_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static SpawnRequest* default_instance_;
};
// -------------------------------------------------------------------

class PropertyRequest : public ::google::protobuf::MessageLite {
 public:
  PropertyRequest();
  virtual ~PropertyRequest();

  PropertyRequest(const PropertyRequest& from);

  inline PropertyRequest& operator=(const PropertyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PropertyRequest& default_instance();

  enum IdentifierCase {
    kEntityName = 1,
    kEntityGuid = 2,
    IDENTIFIER_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PropertyRequest* other);

  // implements Message ----------------------------------------------

  PropertyRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyRequest& from);
  void MergeFrom(const PropertyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string entity_name = 1;
  inline bool has_entity_name() const;
  inline void clear_entity_name();
  static const int kEntityNameFieldNumber = 1;
  inline const ::std::string& entity_name() const;
  inline void set_entity_name(const ::std::string& value);
  inline void set_entity_name(const char* value);
  inline void set_entity_name(const char* value, size_t size);
  inline ::std::string* mutable_entity_name();
  inline ::std::string* release_entity_name();
  inline void set_allocated_entity_name(::std::string* entity_name);

  // optional string entity_guid = 2;
  inline bool has_entity_guid() const;
  inline void clear_entity_guid();
  static const int kEntityGuidFieldNumber = 2;
  inline const ::std::string& entity_guid() const;
  inline void set_entity_guid(const ::std::string& value);
  inline void set_entity_guid(const char* value);
  inline void set_entity_guid(const char* value, size_t size);
  inline ::std::string* mutable_entity_guid();
  inline ::std::string* release_entity_guid();
  inline void set_allocated_entity_guid(::std::string* entity_guid);

  // repeated .g3rc.PropertyIdentifier properties_get = 3;
  inline int properties_get_size() const;
  inline void clear_properties_get();
  static const int kPropertiesGetFieldNumber = 3;
  inline const ::g3rc::PropertyIdentifier& properties_get(int index) const;
  inline ::g3rc::PropertyIdentifier* mutable_properties_get(int index);
  inline ::g3rc::PropertyIdentifier* add_properties_get();
  inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertyIdentifier >&
      properties_get() const;
  inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertyIdentifier >*
      mutable_properties_get();

  // repeated .g3rc.PropertySerialized properties_set = 4;
  inline int properties_set_size() const;
  inline void clear_properties_set();
  static const int kPropertiesSetFieldNumber = 4;
  inline const ::g3rc::PropertySerialized& properties_set(int index) const;
  inline ::g3rc::PropertySerialized* mutable_properties_set(int index);
  inline ::g3rc::PropertySerialized* add_properties_set();
  inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >&
      properties_set() const;
  inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >*
      mutable_properties_set();

  inline IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:g3rc.PropertyRequest)
 private:
  inline void set_has_entity_name();
  inline void set_has_entity_guid();

  inline bool has_identifier();
  void clear_identifier();
  inline void clear_has_identifier();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::g3rc::PropertyIdentifier > properties_get_;
  ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized > properties_set_;
  union IdentifierUnion {
    ::std::string* entity_name_;
    ::std::string* entity_guid_;
  } identifier_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static PropertyRequest* default_instance_;
};
// -------------------------------------------------------------------

class HearbeatResponse : public ::google::protobuf::MessageLite {
 public:
  HearbeatResponse();
  virtual ~HearbeatResponse();

  HearbeatResponse(const HearbeatResponse& from);

  inline HearbeatResponse& operator=(const HearbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HearbeatResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HearbeatResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HearbeatResponse* other);

  // implements Message ----------------------------------------------

  HearbeatResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HearbeatResponse& from);
  void MergeFrom(const HearbeatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HearbeatResponse_Status Status;
  static const Status MENU = HearbeatResponse_Status_MENU;
  static const Status LOADING = HearbeatResponse_Status_LOADING;
  static const Status INGAME = HearbeatResponse_Status_INGAME;
  static inline bool Status_IsValid(int value) {
    return HearbeatResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    HearbeatResponse_Status_Status_MIN;
  static const Status Status_MAX =
    HearbeatResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    HearbeatResponse_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .g3rc.HearbeatResponse.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::g3rc::HearbeatResponse_Status status() const;
  inline void set_status(::g3rc::HearbeatResponse_Status value);

  // @@protoc_insertion_point(class_scope:g3rc.HearbeatResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static HearbeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class VoidResponse : public ::google::protobuf::MessageLite {
 public:
  VoidResponse();
  virtual ~VoidResponse();

  VoidResponse(const VoidResponse& from);

  inline VoidResponse& operator=(const VoidResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VoidResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VoidResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VoidResponse* other);

  // implements Message ----------------------------------------------

  VoidResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VoidResponse& from);
  void MergeFrom(const VoidResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g3rc.VoidResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static VoidResponse* default_instance_;
};
// -------------------------------------------------------------------

class EntityResponse : public ::google::protobuf::MessageLite {
 public:
  EntityResponse();
  virtual ~EntityResponse();

  EntityResponse(const EntityResponse& from);

  inline EntityResponse& operator=(const EntityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EntityResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EntityResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EntityResponse* other);

  // implements Message ----------------------------------------------

  EntityResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EntityResponse& from);
  void MergeFrom(const EntityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .g3rc.Position position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::g3rc::Position& position() const;
  inline ::g3rc::Position* mutable_position();
  inline ::g3rc::Position* release_position();
  inline void set_allocated_position(::g3rc::Position* position);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string guid = 3;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 3;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // @@protoc_insertion_point(class_scope:g3rc.EntityResponse)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::g3rc::Position* position_;
  ::std::string* name_;
  ::std::string* guid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static EntityResponse* default_instance_;
};
// -------------------------------------------------------------------

class PropertyResponse : public ::google::protobuf::MessageLite {
 public:
  PropertyResponse();
  virtual ~PropertyResponse();

  PropertyResponse(const PropertyResponse& from);

  inline PropertyResponse& operator=(const PropertyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PropertyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PropertyResponse* other);

  // implements Message ----------------------------------------------

  PropertyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyResponse& from);
  void MergeFrom(const PropertyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .g3rc.PropertySerialized properties_get = 1;
  inline int properties_get_size() const;
  inline void clear_properties_get();
  static const int kPropertiesGetFieldNumber = 1;
  inline const ::g3rc::PropertySerialized& properties_get(int index) const;
  inline ::g3rc::PropertySerialized* mutable_properties_get(int index);
  inline ::g3rc::PropertySerialized* add_properties_get();
  inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >&
      properties_get() const;
  inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >*
      mutable_properties_get();

  // repeated .g3rc.PropertySerialized properties_set = 2;
  inline int properties_set_size() const;
  inline void clear_properties_set();
  static const int kPropertiesSetFieldNumber = 2;
  inline const ::g3rc::PropertySerialized& properties_set(int index) const;
  inline ::g3rc::PropertySerialized* mutable_properties_set(int index);
  inline ::g3rc::PropertySerialized* add_properties_set();
  inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >&
      properties_set() const;
  inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >*
      mutable_properties_set();

  // @@protoc_insertion_point(class_scope:g3rc.PropertyResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized > properties_get_;
  ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized > properties_set_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static PropertyResponse* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::MessageLite {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Position& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Position* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .g3rc.Vector translation = 1;
  inline bool has_translation() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 1;
  inline const ::g3rc::Vector& translation() const;
  inline ::g3rc::Vector* mutable_translation();
  inline ::g3rc::Vector* release_translation();
  inline void set_allocated_translation(::g3rc::Vector* translation);

  // required .g3rc.Vector scale = 2;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 2;
  inline const ::g3rc::Vector& scale() const;
  inline ::g3rc::Vector* mutable_scale();
  inline ::g3rc::Vector* release_scale();
  inline void set_allocated_scale(::g3rc::Vector* scale);

  // required .g3rc.EulerAngles rotation = 3;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 3;
  inline const ::g3rc::EulerAngles& rotation() const;
  inline ::g3rc::EulerAngles* mutable_rotation();
  inline ::g3rc::EulerAngles* release_rotation();
  inline void set_allocated_rotation(::g3rc::EulerAngles* rotation);

  // @@protoc_insertion_point(class_scope:g3rc.Position)
 private:
  inline void set_has_translation();
  inline void clear_has_translation();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_rotation();
  inline void clear_has_rotation();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::g3rc::Vector* translation_;
  ::g3rc::Vector* scale_;
  ::g3rc::EulerAngles* rotation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::MessageLite {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Vector& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Vector* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Vector* other);

  // implements Message ----------------------------------------------

  Vector* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:g3rc.Vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class EulerAngles : public ::google::protobuf::MessageLite {
 public:
  EulerAngles();
  virtual ~EulerAngles();

  EulerAngles(const EulerAngles& from);

  inline EulerAngles& operator=(const EulerAngles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EulerAngles& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EulerAngles* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EulerAngles* other);

  // implements Message ----------------------------------------------

  EulerAngles* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EulerAngles& from);
  void MergeFrom(const EulerAngles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float yaw = 1;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 1;
  inline float yaw() const;
  inline void set_yaw(float value);

  // required float pitch = 2;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 2;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float roll = 3;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 3;
  inline float roll() const;
  inline void set_roll(float value);

  // @@protoc_insertion_point(class_scope:g3rc.EulerAngles)
 private:
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float yaw_;
  float pitch_;
  float roll_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static EulerAngles* default_instance_;
};
// -------------------------------------------------------------------

class PropertyIdentifier : public ::google::protobuf::MessageLite {
 public:
  PropertyIdentifier();
  virtual ~PropertyIdentifier();

  PropertyIdentifier(const PropertyIdentifier& from);

  inline PropertyIdentifier& operator=(const PropertyIdentifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PropertyIdentifier& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyIdentifier* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PropertyIdentifier* other);

  // implements Message ----------------------------------------------

  PropertyIdentifier* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyIdentifier& from);
  void MergeFrom(const PropertyIdentifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string property_set = 1;
  inline bool has_property_set() const;
  inline void clear_property_set();
  static const int kPropertySetFieldNumber = 1;
  inline const ::std::string& property_set() const;
  inline void set_property_set(const ::std::string& value);
  inline void set_property_set(const char* value);
  inline void set_property_set(const char* value, size_t size);
  inline ::std::string* mutable_property_set();
  inline ::std::string* release_property_set();
  inline void set_allocated_property_set(::std::string* property_set);

  // optional string property = 2;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 2;
  inline const ::std::string& property() const;
  inline void set_property(const ::std::string& value);
  inline void set_property(const char* value);
  inline void set_property(const char* value, size_t size);
  inline ::std::string* mutable_property();
  inline ::std::string* release_property();
  inline void set_allocated_property(::std::string* property);

  // @@protoc_insertion_point(class_scope:g3rc.PropertyIdentifier)
 private:
  inline void set_has_property_set();
  inline void clear_has_property_set();
  inline void set_has_property();
  inline void clear_has_property();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* property_set_;
  ::std::string* property_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static PropertyIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class PropertySerialized : public ::google::protobuf::MessageLite {
 public:
  PropertySerialized();
  virtual ~PropertySerialized();

  PropertySerialized(const PropertySerialized& from);

  inline PropertySerialized& operator=(const PropertySerialized& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PropertySerialized& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertySerialized* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PropertySerialized* other);

  // implements Message ----------------------------------------------

  PropertySerialized* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertySerialized& from);
  void MergeFrom(const PropertySerialized& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .g3rc.PropertyIdentifier identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::g3rc::PropertyIdentifier& identifier() const;
  inline ::g3rc::PropertyIdentifier* mutable_identifier();
  inline ::g3rc::PropertyIdentifier* release_identifier();
  inline void set_allocated_identifier(::g3rc::PropertyIdentifier* identifier);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:g3rc.PropertySerialized)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::g3rc::PropertyIdentifier* identifier_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_g3rc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_g3rc_2eproto();
  #endif
  friend void protobuf_AssignDesc_g3rc_2eproto();
  friend void protobuf_ShutdownFile_g3rc_2eproto();

  void InitAsDefaultInstance();
  static PropertySerialized* default_instance_;
};
// ===================================================================


// ===================================================================

// RequestContainer

// required uint32 request_number = 1;
inline bool RequestContainer::has_request_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestContainer::set_has_request_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestContainer::clear_has_request_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestContainer::clear_request_number() {
  request_number_ = 0u;
  clear_has_request_number();
}
inline ::google::protobuf::uint32 RequestContainer::request_number() const {
  // @@protoc_insertion_point(field_get:g3rc.RequestContainer.request_number)
  return request_number_;
}
inline void RequestContainer::set_request_number(::google::protobuf::uint32 value) {
  set_has_request_number();
  request_number_ = value;
  // @@protoc_insertion_point(field_set:g3rc.RequestContainer.request_number)
}

// optional .g3rc.HearbeatRequest heartbeat_request = 2;
inline bool RequestContainer::has_heartbeat_request() const {
  return request_case() == kHeartbeatRequest;
}
inline void RequestContainer::set_has_heartbeat_request() {
  _oneof_case_[0] = kHeartbeatRequest;
}
inline void RequestContainer::clear_heartbeat_request() {
  if (has_heartbeat_request()) {
    delete request_.heartbeat_request_;
    clear_has_request();
  }
}
inline const ::g3rc::HearbeatRequest& RequestContainer::heartbeat_request() const {
  return has_heartbeat_request() ? *request_.heartbeat_request_
                      : ::g3rc::HearbeatRequest::default_instance();
}
inline ::g3rc::HearbeatRequest* RequestContainer::mutable_heartbeat_request() {
  if (!has_heartbeat_request()) {
    clear_request();
    set_has_heartbeat_request();
    request_.heartbeat_request_ = new ::g3rc::HearbeatRequest;
  }
  return request_.heartbeat_request_;
}
inline ::g3rc::HearbeatRequest* RequestContainer::release_heartbeat_request() {
  if (has_heartbeat_request()) {
    clear_has_request();
    ::g3rc::HearbeatRequest* temp = request_.heartbeat_request_;
    request_.heartbeat_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RequestContainer::set_allocated_heartbeat_request(::g3rc::HearbeatRequest* heartbeat_request) {
  clear_request();
  if (heartbeat_request) {
    set_has_heartbeat_request();
    request_.heartbeat_request_ = heartbeat_request;
  }
}

// optional .g3rc.EntityRequest entity_request = 3;
inline bool RequestContainer::has_entity_request() const {
  return request_case() == kEntityRequest;
}
inline void RequestContainer::set_has_entity_request() {
  _oneof_case_[0] = kEntityRequest;
}
inline void RequestContainer::clear_entity_request() {
  if (has_entity_request()) {
    delete request_.entity_request_;
    clear_has_request();
  }
}
inline const ::g3rc::EntityRequest& RequestContainer::entity_request() const {
  return has_entity_request() ? *request_.entity_request_
                      : ::g3rc::EntityRequest::default_instance();
}
inline ::g3rc::EntityRequest* RequestContainer::mutable_entity_request() {
  if (!has_entity_request()) {
    clear_request();
    set_has_entity_request();
    request_.entity_request_ = new ::g3rc::EntityRequest;
  }
  return request_.entity_request_;
}
inline ::g3rc::EntityRequest* RequestContainer::release_entity_request() {
  if (has_entity_request()) {
    clear_has_request();
    ::g3rc::EntityRequest* temp = request_.entity_request_;
    request_.entity_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RequestContainer::set_allocated_entity_request(::g3rc::EntityRequest* entity_request) {
  clear_request();
  if (entity_request) {
    set_has_entity_request();
    request_.entity_request_ = entity_request;
  }
}

// optional .g3rc.GotoRequest goto_request = 4;
inline bool RequestContainer::has_goto_request() const {
  return request_case() == kGotoRequest;
}
inline void RequestContainer::set_has_goto_request() {
  _oneof_case_[0] = kGotoRequest;
}
inline void RequestContainer::clear_goto_request() {
  if (has_goto_request()) {
    delete request_.goto_request_;
    clear_has_request();
  }
}
inline const ::g3rc::GotoRequest& RequestContainer::goto_request() const {
  return has_goto_request() ? *request_.goto_request_
                      : ::g3rc::GotoRequest::default_instance();
}
inline ::g3rc::GotoRequest* RequestContainer::mutable_goto_request() {
  if (!has_goto_request()) {
    clear_request();
    set_has_goto_request();
    request_.goto_request_ = new ::g3rc::GotoRequest;
  }
  return request_.goto_request_;
}
inline ::g3rc::GotoRequest* RequestContainer::release_goto_request() {
  if (has_goto_request()) {
    clear_has_request();
    ::g3rc::GotoRequest* temp = request_.goto_request_;
    request_.goto_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RequestContainer::set_allocated_goto_request(::g3rc::GotoRequest* goto_request) {
  clear_request();
  if (goto_request) {
    set_has_goto_request();
    request_.goto_request_ = goto_request;
  }
}

// optional .g3rc.SpawnRequest spawn_request = 5;
inline bool RequestContainer::has_spawn_request() const {
  return request_case() == kSpawnRequest;
}
inline void RequestContainer::set_has_spawn_request() {
  _oneof_case_[0] = kSpawnRequest;
}
inline void RequestContainer::clear_spawn_request() {
  if (has_spawn_request()) {
    delete request_.spawn_request_;
    clear_has_request();
  }
}
inline const ::g3rc::SpawnRequest& RequestContainer::spawn_request() const {
  return has_spawn_request() ? *request_.spawn_request_
                      : ::g3rc::SpawnRequest::default_instance();
}
inline ::g3rc::SpawnRequest* RequestContainer::mutable_spawn_request() {
  if (!has_spawn_request()) {
    clear_request();
    set_has_spawn_request();
    request_.spawn_request_ = new ::g3rc::SpawnRequest;
  }
  return request_.spawn_request_;
}
inline ::g3rc::SpawnRequest* RequestContainer::release_spawn_request() {
  if (has_spawn_request()) {
    clear_has_request();
    ::g3rc::SpawnRequest* temp = request_.spawn_request_;
    request_.spawn_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RequestContainer::set_allocated_spawn_request(::g3rc::SpawnRequest* spawn_request) {
  clear_request();
  if (spawn_request) {
    set_has_spawn_request();
    request_.spawn_request_ = spawn_request;
  }
}

// optional .g3rc.PropertyRequest property_request = 6;
inline bool RequestContainer::has_property_request() const {
  return request_case() == kPropertyRequest;
}
inline void RequestContainer::set_has_property_request() {
  _oneof_case_[0] = kPropertyRequest;
}
inline void RequestContainer::clear_property_request() {
  if (has_property_request()) {
    delete request_.property_request_;
    clear_has_request();
  }
}
inline const ::g3rc::PropertyRequest& RequestContainer::property_request() const {
  return has_property_request() ? *request_.property_request_
                      : ::g3rc::PropertyRequest::default_instance();
}
inline ::g3rc::PropertyRequest* RequestContainer::mutable_property_request() {
  if (!has_property_request()) {
    clear_request();
    set_has_property_request();
    request_.property_request_ = new ::g3rc::PropertyRequest;
  }
  return request_.property_request_;
}
inline ::g3rc::PropertyRequest* RequestContainer::release_property_request() {
  if (has_property_request()) {
    clear_has_request();
    ::g3rc::PropertyRequest* temp = request_.property_request_;
    request_.property_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RequestContainer::set_allocated_property_request(::g3rc::PropertyRequest* property_request) {
  clear_request();
  if (property_request) {
    set_has_property_request();
    request_.property_request_ = property_request;
  }
}

inline bool RequestContainer::has_request() {
  return request_case() != REQUEST_NOT_SET;
}
inline void RequestContainer::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline RequestContainer::RequestCase RequestContainer::request_case() const {
  return RequestContainer::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseContainer

// required uint32 request_number = 1;
inline bool ResponseContainer::has_request_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseContainer::set_has_request_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseContainer::clear_has_request_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseContainer::clear_request_number() {
  request_number_ = 0u;
  clear_has_request_number();
}
inline ::google::protobuf::uint32 ResponseContainer::request_number() const {
  // @@protoc_insertion_point(field_get:g3rc.ResponseContainer.request_number)
  return request_number_;
}
inline void ResponseContainer::set_request_number(::google::protobuf::uint32 value) {
  set_has_request_number();
  request_number_ = value;
  // @@protoc_insertion_point(field_set:g3rc.ResponseContainer.request_number)
}

// required .g3rc.ResponseContainer.Status status = 2;
inline bool ResponseContainer::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseContainer::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseContainer::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseContainer::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::g3rc::ResponseContainer_Status ResponseContainer::status() const {
  // @@protoc_insertion_point(field_get:g3rc.ResponseContainer.status)
  return static_cast< ::g3rc::ResponseContainer_Status >(status_);
}
inline void ResponseContainer::set_status(::g3rc::ResponseContainer_Status value) {
  assert(::g3rc::ResponseContainer_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:g3rc.ResponseContainer.status)
}

// optional string message = 3;
inline bool ResponseContainer::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseContainer::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseContainer::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseContainer::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ResponseContainer::message() const {
  // @@protoc_insertion_point(field_get:g3rc.ResponseContainer.message)
  return *message_;
}
inline void ResponseContainer::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:g3rc.ResponseContainer.message)
}
inline void ResponseContainer::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:g3rc.ResponseContainer.message)
}
inline void ResponseContainer::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:g3rc.ResponseContainer.message)
}
inline ::std::string* ResponseContainer::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:g3rc.ResponseContainer.message)
  return message_;
}
inline ::std::string* ResponseContainer::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResponseContainer::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.ResponseContainer.message)
}

// optional .g3rc.HearbeatResponse heartbeat_response = 4;
inline bool ResponseContainer::has_heartbeat_response() const {
  return response_case() == kHeartbeatResponse;
}
inline void ResponseContainer::set_has_heartbeat_response() {
  _oneof_case_[0] = kHeartbeatResponse;
}
inline void ResponseContainer::clear_heartbeat_response() {
  if (has_heartbeat_response()) {
    delete response_.heartbeat_response_;
    clear_has_response();
  }
}
inline const ::g3rc::HearbeatResponse& ResponseContainer::heartbeat_response() const {
  return has_heartbeat_response() ? *response_.heartbeat_response_
                      : ::g3rc::HearbeatResponse::default_instance();
}
inline ::g3rc::HearbeatResponse* ResponseContainer::mutable_heartbeat_response() {
  if (!has_heartbeat_response()) {
    clear_response();
    set_has_heartbeat_response();
    response_.heartbeat_response_ = new ::g3rc::HearbeatResponse;
  }
  return response_.heartbeat_response_;
}
inline ::g3rc::HearbeatResponse* ResponseContainer::release_heartbeat_response() {
  if (has_heartbeat_response()) {
    clear_has_response();
    ::g3rc::HearbeatResponse* temp = response_.heartbeat_response_;
    response_.heartbeat_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseContainer::set_allocated_heartbeat_response(::g3rc::HearbeatResponse* heartbeat_response) {
  clear_response();
  if (heartbeat_response) {
    set_has_heartbeat_response();
    response_.heartbeat_response_ = heartbeat_response;
  }
}

// optional .g3rc.EntityResponse entity_response = 5;
inline bool ResponseContainer::has_entity_response() const {
  return response_case() == kEntityResponse;
}
inline void ResponseContainer::set_has_entity_response() {
  _oneof_case_[0] = kEntityResponse;
}
inline void ResponseContainer::clear_entity_response() {
  if (has_entity_response()) {
    delete response_.entity_response_;
    clear_has_response();
  }
}
inline const ::g3rc::EntityResponse& ResponseContainer::entity_response() const {
  return has_entity_response() ? *response_.entity_response_
                      : ::g3rc::EntityResponse::default_instance();
}
inline ::g3rc::EntityResponse* ResponseContainer::mutable_entity_response() {
  if (!has_entity_response()) {
    clear_response();
    set_has_entity_response();
    response_.entity_response_ = new ::g3rc::EntityResponse;
  }
  return response_.entity_response_;
}
inline ::g3rc::EntityResponse* ResponseContainer::release_entity_response() {
  if (has_entity_response()) {
    clear_has_response();
    ::g3rc::EntityResponse* temp = response_.entity_response_;
    response_.entity_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseContainer::set_allocated_entity_response(::g3rc::EntityResponse* entity_response) {
  clear_response();
  if (entity_response) {
    set_has_entity_response();
    response_.entity_response_ = entity_response;
  }
}

// optional .g3rc.VoidResponse void_response = 6;
inline bool ResponseContainer::has_void_response() const {
  return response_case() == kVoidResponse;
}
inline void ResponseContainer::set_has_void_response() {
  _oneof_case_[0] = kVoidResponse;
}
inline void ResponseContainer::clear_void_response() {
  if (has_void_response()) {
    delete response_.void_response_;
    clear_has_response();
  }
}
inline const ::g3rc::VoidResponse& ResponseContainer::void_response() const {
  return has_void_response() ? *response_.void_response_
                      : ::g3rc::VoidResponse::default_instance();
}
inline ::g3rc::VoidResponse* ResponseContainer::mutable_void_response() {
  if (!has_void_response()) {
    clear_response();
    set_has_void_response();
    response_.void_response_ = new ::g3rc::VoidResponse;
  }
  return response_.void_response_;
}
inline ::g3rc::VoidResponse* ResponseContainer::release_void_response() {
  if (has_void_response()) {
    clear_has_response();
    ::g3rc::VoidResponse* temp = response_.void_response_;
    response_.void_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseContainer::set_allocated_void_response(::g3rc::VoidResponse* void_response) {
  clear_response();
  if (void_response) {
    set_has_void_response();
    response_.void_response_ = void_response;
  }
}

// optional .g3rc.PropertyResponse property_response = 7;
inline bool ResponseContainer::has_property_response() const {
  return response_case() == kPropertyResponse;
}
inline void ResponseContainer::set_has_property_response() {
  _oneof_case_[0] = kPropertyResponse;
}
inline void ResponseContainer::clear_property_response() {
  if (has_property_response()) {
    delete response_.property_response_;
    clear_has_response();
  }
}
inline const ::g3rc::PropertyResponse& ResponseContainer::property_response() const {
  return has_property_response() ? *response_.property_response_
                      : ::g3rc::PropertyResponse::default_instance();
}
inline ::g3rc::PropertyResponse* ResponseContainer::mutable_property_response() {
  if (!has_property_response()) {
    clear_response();
    set_has_property_response();
    response_.property_response_ = new ::g3rc::PropertyResponse;
  }
  return response_.property_response_;
}
inline ::g3rc::PropertyResponse* ResponseContainer::release_property_response() {
  if (has_property_response()) {
    clear_has_response();
    ::g3rc::PropertyResponse* temp = response_.property_response_;
    response_.property_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseContainer::set_allocated_property_response(::g3rc::PropertyResponse* property_response) {
  clear_response();
  if (property_response) {
    set_has_property_response();
    response_.property_response_ = property_response;
  }
}

inline bool ResponseContainer::has_response() {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ResponseContainer::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ResponseContainer::ResponseCase ResponseContainer::response_case() const {
  return ResponseContainer::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HearbeatRequest

// -------------------------------------------------------------------

// EntityRequest

// optional string name = 1;
inline bool EntityRequest::has_name() const {
  return identifier_case() == kName;
}
inline void EntityRequest::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void EntityRequest::clear_name() {
  if (has_name()) {
    delete identifier_.name_;
    clear_has_identifier();
  }
}
inline const ::std::string& EntityRequest::name() const {
  if (has_name()) {
    return *identifier_.name_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void EntityRequest::set_name(const ::std::string& value) {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  identifier_.name_->assign(value);
}
inline void EntityRequest::set_name(const char* value) {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  identifier_.name_->assign(value);
}
inline void EntityRequest::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  identifier_.name_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityRequest::mutable_name() {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  return identifier_.name_;
}
inline ::std::string* EntityRequest::release_name() {
  if (has_name()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.name_;
    identifier_.name_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EntityRequest::set_allocated_name(::std::string* name) {
  clear_identifier();
  if (name) {
    set_has_name();
    identifier_.name_ = name;
  }
}

// optional string guid = 2;
inline bool EntityRequest::has_guid() const {
  return identifier_case() == kGuid;
}
inline void EntityRequest::set_has_guid() {
  _oneof_case_[0] = kGuid;
}
inline void EntityRequest::clear_guid() {
  if (has_guid()) {
    delete identifier_.guid_;
    clear_has_identifier();
  }
}
inline const ::std::string& EntityRequest::guid() const {
  if (has_guid()) {
    return *identifier_.guid_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void EntityRequest::set_guid(const ::std::string& value) {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  identifier_.guid_->assign(value);
}
inline void EntityRequest::set_guid(const char* value) {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  identifier_.guid_->assign(value);
}
inline void EntityRequest::set_guid(const char* value, size_t size) {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  identifier_.guid_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityRequest::mutable_guid() {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  return identifier_.guid_;
}
inline ::std::string* EntityRequest::release_guid() {
  if (has_guid()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.guid_;
    identifier_.guid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EntityRequest::set_allocated_guid(::std::string* guid) {
  clear_identifier();
  if (guid) {
    set_has_guid();
    identifier_.guid_ = guid;
  }
}

// optional bool focus = 3;
inline bool EntityRequest::has_focus() const {
  return identifier_case() == kFocus;
}
inline void EntityRequest::set_has_focus() {
  _oneof_case_[0] = kFocus;
}
inline void EntityRequest::clear_focus() {
  if (has_focus()) {
    identifier_.focus_ = false;
    clear_has_identifier();
  }
}
inline bool EntityRequest::focus() const {
  if (has_focus()) {
    return identifier_.focus_;
  }
  return false;
}
inline void EntityRequest::set_focus(bool value) {
  if (!has_focus()) {
    clear_identifier();
    set_has_focus();
  }
  identifier_.focus_ = value;
}

// optional bool editor = 6;
inline bool EntityRequest::has_editor() const {
  return identifier_case() == kEditor;
}
inline void EntityRequest::set_has_editor() {
  _oneof_case_[0] = kEditor;
}
inline void EntityRequest::clear_editor() {
  if (has_editor()) {
    identifier_.editor_ = false;
    clear_has_identifier();
  }
}
inline bool EntityRequest::editor() const {
  if (has_editor()) {
    return identifier_.editor_;
  }
  return false;
}
inline void EntityRequest::set_editor(bool value) {
  if (!has_editor()) {
    clear_identifier();
    set_has_editor();
  }
  identifier_.editor_ = value;
}

// optional .g3rc.Position moveto = 4;
inline bool EntityRequest::has_moveto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EntityRequest::set_has_moveto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EntityRequest::clear_has_moveto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EntityRequest::clear_moveto() {
  if (moveto_ != NULL) moveto_->::g3rc::Position::Clear();
  clear_has_moveto();
}
inline const ::g3rc::Position& EntityRequest::moveto() const {
  // @@protoc_insertion_point(field_get:g3rc.EntityRequest.moveto)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return moveto_ != NULL ? *moveto_ : *default_instance().moveto_;
#else
  return moveto_ != NULL ? *moveto_ : *default_instance_->moveto_;
#endif
}
inline ::g3rc::Position* EntityRequest::mutable_moveto() {
  set_has_moveto();
  if (moveto_ == NULL) moveto_ = new ::g3rc::Position;
  // @@protoc_insertion_point(field_mutable:g3rc.EntityRequest.moveto)
  return moveto_;
}
inline ::g3rc::Position* EntityRequest::release_moveto() {
  clear_has_moveto();
  ::g3rc::Position* temp = moveto_;
  moveto_ = NULL;
  return temp;
}
inline void EntityRequest::set_allocated_moveto(::g3rc::Position* moveto) {
  delete moveto_;
  moveto_ = moveto;
  if (moveto) {
    set_has_moveto();
  } else {
    clear_has_moveto();
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.EntityRequest.moveto)
}

// optional bool put_to_ground = 5;
inline bool EntityRequest::has_put_to_ground() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EntityRequest::set_has_put_to_ground() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EntityRequest::clear_has_put_to_ground() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EntityRequest::clear_put_to_ground() {
  put_to_ground_ = false;
  clear_has_put_to_ground();
}
inline bool EntityRequest::put_to_ground() const {
  // @@protoc_insertion_point(field_get:g3rc.EntityRequest.put_to_ground)
  return put_to_ground_;
}
inline void EntityRequest::set_put_to_ground(bool value) {
  set_has_put_to_ground();
  put_to_ground_ = value;
  // @@protoc_insertion_point(field_set:g3rc.EntityRequest.put_to_ground)
}

inline bool EntityRequest::has_identifier() {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void EntityRequest::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline EntityRequest::IdentifierCase EntityRequest::identifier_case() const {
  return EntityRequest::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GotoRequest

// optional string name = 1;
inline bool GotoRequest::has_name() const {
  return identifier_case() == kName;
}
inline void GotoRequest::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void GotoRequest::clear_name() {
  if (has_name()) {
    delete identifier_.name_;
    clear_has_identifier();
  }
}
inline const ::std::string& GotoRequest::name() const {
  if (has_name()) {
    return *identifier_.name_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void GotoRequest::set_name(const ::std::string& value) {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  identifier_.name_->assign(value);
}
inline void GotoRequest::set_name(const char* value) {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  identifier_.name_->assign(value);
}
inline void GotoRequest::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  identifier_.name_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GotoRequest::mutable_name() {
  if (!has_name()) {
    clear_identifier();
    set_has_name();
    identifier_.name_ = new ::std::string;
  }
  return identifier_.name_;
}
inline ::std::string* GotoRequest::release_name() {
  if (has_name()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.name_;
    identifier_.name_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GotoRequest::set_allocated_name(::std::string* name) {
  clear_identifier();
  if (name) {
    set_has_name();
    identifier_.name_ = name;
  }
}

// optional string guid = 2;
inline bool GotoRequest::has_guid() const {
  return identifier_case() == kGuid;
}
inline void GotoRequest::set_has_guid() {
  _oneof_case_[0] = kGuid;
}
inline void GotoRequest::clear_guid() {
  if (has_guid()) {
    delete identifier_.guid_;
    clear_has_identifier();
  }
}
inline const ::std::string& GotoRequest::guid() const {
  if (has_guid()) {
    return *identifier_.guid_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void GotoRequest::set_guid(const ::std::string& value) {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  identifier_.guid_->assign(value);
}
inline void GotoRequest::set_guid(const char* value) {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  identifier_.guid_->assign(value);
}
inline void GotoRequest::set_guid(const char* value, size_t size) {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  identifier_.guid_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GotoRequest::mutable_guid() {
  if (!has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_ = new ::std::string;
  }
  return identifier_.guid_;
}
inline ::std::string* GotoRequest::release_guid() {
  if (has_guid()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.guid_;
    identifier_.guid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GotoRequest::set_allocated_guid(::std::string* guid) {
  clear_identifier();
  if (guid) {
    set_has_guid();
    identifier_.guid_ = guid;
  }
}

// optional .g3rc.Vector position = 3;
inline bool GotoRequest::has_position() const {
  return identifier_case() == kPosition;
}
inline void GotoRequest::set_has_position() {
  _oneof_case_[0] = kPosition;
}
inline void GotoRequest::clear_position() {
  if (has_position()) {
    delete identifier_.position_;
    clear_has_identifier();
  }
}
inline const ::g3rc::Vector& GotoRequest::position() const {
  return has_position() ? *identifier_.position_
                      : ::g3rc::Vector::default_instance();
}
inline ::g3rc::Vector* GotoRequest::mutable_position() {
  if (!has_position()) {
    clear_identifier();
    set_has_position();
    identifier_.position_ = new ::g3rc::Vector;
  }
  return identifier_.position_;
}
inline ::g3rc::Vector* GotoRequest::release_position() {
  if (has_position()) {
    clear_has_identifier();
    ::g3rc::Vector* temp = identifier_.position_;
    identifier_.position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GotoRequest::set_allocated_position(::g3rc::Vector* position) {
  clear_identifier();
  if (position) {
    set_has_position();
    identifier_.position_ = position;
  }
}

// optional bool put_to_ground = 4;
inline bool GotoRequest::has_put_to_ground() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GotoRequest::set_has_put_to_ground() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GotoRequest::clear_has_put_to_ground() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GotoRequest::clear_put_to_ground() {
  put_to_ground_ = false;
  clear_has_put_to_ground();
}
inline bool GotoRequest::put_to_ground() const {
  // @@protoc_insertion_point(field_get:g3rc.GotoRequest.put_to_ground)
  return put_to_ground_;
}
inline void GotoRequest::set_put_to_ground(bool value) {
  set_has_put_to_ground();
  put_to_ground_ = value;
  // @@protoc_insertion_point(field_set:g3rc.GotoRequest.put_to_ground)
}

inline bool GotoRequest::has_identifier() {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void GotoRequest::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline GotoRequest::IdentifierCase GotoRequest::identifier_case() const {
  return GotoRequest::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SpawnRequest

// optional string template_name = 1;
inline bool SpawnRequest::has_template_name() const {
  return identifier_case() == kTemplateName;
}
inline void SpawnRequest::set_has_template_name() {
  _oneof_case_[0] = kTemplateName;
}
inline void SpawnRequest::clear_template_name() {
  if (has_template_name()) {
    delete identifier_.template_name_;
    clear_has_identifier();
  }
}
inline const ::std::string& SpawnRequest::template_name() const {
  if (has_template_name()) {
    return *identifier_.template_name_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SpawnRequest::set_template_name(const ::std::string& value) {
  if (!has_template_name()) {
    clear_identifier();
    set_has_template_name();
    identifier_.template_name_ = new ::std::string;
  }
  identifier_.template_name_->assign(value);
}
inline void SpawnRequest::set_template_name(const char* value) {
  if (!has_template_name()) {
    clear_identifier();
    set_has_template_name();
    identifier_.template_name_ = new ::std::string;
  }
  identifier_.template_name_->assign(value);
}
inline void SpawnRequest::set_template_name(const char* value, size_t size) {
  if (!has_template_name()) {
    clear_identifier();
    set_has_template_name();
    identifier_.template_name_ = new ::std::string;
  }
  identifier_.template_name_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpawnRequest::mutable_template_name() {
  if (!has_template_name()) {
    clear_identifier();
    set_has_template_name();
    identifier_.template_name_ = new ::std::string;
  }
  return identifier_.template_name_;
}
inline ::std::string* SpawnRequest::release_template_name() {
  if (has_template_name()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.template_name_;
    identifier_.template_name_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SpawnRequest::set_allocated_template_name(::std::string* template_name) {
  clear_identifier();
  if (template_name) {
    set_has_template_name();
    identifier_.template_name_ = template_name;
  }
}

// optional string template_guid = 2;
inline bool SpawnRequest::has_template_guid() const {
  return identifier_case() == kTemplateGuid;
}
inline void SpawnRequest::set_has_template_guid() {
  _oneof_case_[0] = kTemplateGuid;
}
inline void SpawnRequest::clear_template_guid() {
  if (has_template_guid()) {
    delete identifier_.template_guid_;
    clear_has_identifier();
  }
}
inline const ::std::string& SpawnRequest::template_guid() const {
  if (has_template_guid()) {
    return *identifier_.template_guid_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SpawnRequest::set_template_guid(const ::std::string& value) {
  if (!has_template_guid()) {
    clear_identifier();
    set_has_template_guid();
    identifier_.template_guid_ = new ::std::string;
  }
  identifier_.template_guid_->assign(value);
}
inline void SpawnRequest::set_template_guid(const char* value) {
  if (!has_template_guid()) {
    clear_identifier();
    set_has_template_guid();
    identifier_.template_guid_ = new ::std::string;
  }
  identifier_.template_guid_->assign(value);
}
inline void SpawnRequest::set_template_guid(const char* value, size_t size) {
  if (!has_template_guid()) {
    clear_identifier();
    set_has_template_guid();
    identifier_.template_guid_ = new ::std::string;
  }
  identifier_.template_guid_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpawnRequest::mutable_template_guid() {
  if (!has_template_guid()) {
    clear_identifier();
    set_has_template_guid();
    identifier_.template_guid_ = new ::std::string;
  }
  return identifier_.template_guid_;
}
inline ::std::string* SpawnRequest::release_template_guid() {
  if (has_template_guid()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.template_guid_;
    identifier_.template_guid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SpawnRequest::set_allocated_template_guid(::std::string* template_guid) {
  clear_identifier();
  if (template_guid) {
    set_has_template_guid();
    identifier_.template_guid_ = template_guid;
  }
}

// optional string entity_name = 3;
inline bool SpawnRequest::has_entity_name() const {
  return location_case() == kEntityName;
}
inline void SpawnRequest::set_has_entity_name() {
  _oneof_case_[1] = kEntityName;
}
inline void SpawnRequest::clear_entity_name() {
  if (has_entity_name()) {
    delete location_.entity_name_;
    clear_has_location();
  }
}
inline const ::std::string& SpawnRequest::entity_name() const {
  if (has_entity_name()) {
    return *location_.entity_name_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SpawnRequest::set_entity_name(const ::std::string& value) {
  if (!has_entity_name()) {
    clear_location();
    set_has_entity_name();
    location_.entity_name_ = new ::std::string;
  }
  location_.entity_name_->assign(value);
}
inline void SpawnRequest::set_entity_name(const char* value) {
  if (!has_entity_name()) {
    clear_location();
    set_has_entity_name();
    location_.entity_name_ = new ::std::string;
  }
  location_.entity_name_->assign(value);
}
inline void SpawnRequest::set_entity_name(const char* value, size_t size) {
  if (!has_entity_name()) {
    clear_location();
    set_has_entity_name();
    location_.entity_name_ = new ::std::string;
  }
  location_.entity_name_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpawnRequest::mutable_entity_name() {
  if (!has_entity_name()) {
    clear_location();
    set_has_entity_name();
    location_.entity_name_ = new ::std::string;
  }
  return location_.entity_name_;
}
inline ::std::string* SpawnRequest::release_entity_name() {
  if (has_entity_name()) {
    clear_has_location();
    ::std::string* temp = location_.entity_name_;
    location_.entity_name_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SpawnRequest::set_allocated_entity_name(::std::string* entity_name) {
  clear_location();
  if (entity_name) {
    set_has_entity_name();
    location_.entity_name_ = entity_name;
  }
}

// optional string entity_guid = 4;
inline bool SpawnRequest::has_entity_guid() const {
  return location_case() == kEntityGuid;
}
inline void SpawnRequest::set_has_entity_guid() {
  _oneof_case_[1] = kEntityGuid;
}
inline void SpawnRequest::clear_entity_guid() {
  if (has_entity_guid()) {
    delete location_.entity_guid_;
    clear_has_location();
  }
}
inline const ::std::string& SpawnRequest::entity_guid() const {
  if (has_entity_guid()) {
    return *location_.entity_guid_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SpawnRequest::set_entity_guid(const ::std::string& value) {
  if (!has_entity_guid()) {
    clear_location();
    set_has_entity_guid();
    location_.entity_guid_ = new ::std::string;
  }
  location_.entity_guid_->assign(value);
}
inline void SpawnRequest::set_entity_guid(const char* value) {
  if (!has_entity_guid()) {
    clear_location();
    set_has_entity_guid();
    location_.entity_guid_ = new ::std::string;
  }
  location_.entity_guid_->assign(value);
}
inline void SpawnRequest::set_entity_guid(const char* value, size_t size) {
  if (!has_entity_guid()) {
    clear_location();
    set_has_entity_guid();
    location_.entity_guid_ = new ::std::string;
  }
  location_.entity_guid_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpawnRequest::mutable_entity_guid() {
  if (!has_entity_guid()) {
    clear_location();
    set_has_entity_guid();
    location_.entity_guid_ = new ::std::string;
  }
  return location_.entity_guid_;
}
inline ::std::string* SpawnRequest::release_entity_guid() {
  if (has_entity_guid()) {
    clear_has_location();
    ::std::string* temp = location_.entity_guid_;
    location_.entity_guid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SpawnRequest::set_allocated_entity_guid(::std::string* entity_guid) {
  clear_location();
  if (entity_guid) {
    set_has_entity_guid();
    location_.entity_guid_ = entity_guid;
  }
}

// optional .g3rc.Vector position = 5;
inline bool SpawnRequest::has_position() const {
  return location_case() == kPosition;
}
inline void SpawnRequest::set_has_position() {
  _oneof_case_[1] = kPosition;
}
inline void SpawnRequest::clear_position() {
  if (has_position()) {
    delete location_.position_;
    clear_has_location();
  }
}
inline const ::g3rc::Vector& SpawnRequest::position() const {
  return has_position() ? *location_.position_
                      : ::g3rc::Vector::default_instance();
}
inline ::g3rc::Vector* SpawnRequest::mutable_position() {
  if (!has_position()) {
    clear_location();
    set_has_position();
    location_.position_ = new ::g3rc::Vector;
  }
  return location_.position_;
}
inline ::g3rc::Vector* SpawnRequest::release_position() {
  if (has_position()) {
    clear_has_location();
    ::g3rc::Vector* temp = location_.position_;
    location_.position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SpawnRequest::set_allocated_position(::g3rc::Vector* position) {
  clear_location();
  if (position) {
    set_has_position();
    location_.position_ = position;
  }
}

inline bool SpawnRequest::has_identifier() {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void SpawnRequest::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline bool SpawnRequest::has_location() {
  return location_case() != LOCATION_NOT_SET;
}
inline void SpawnRequest::clear_has_location() {
  _oneof_case_[1] = LOCATION_NOT_SET;
}
inline SpawnRequest::IdentifierCase SpawnRequest::identifier_case() const {
  return SpawnRequest::IdentifierCase(_oneof_case_[0]);
}
inline SpawnRequest::LocationCase SpawnRequest::location_case() const {
  return SpawnRequest::LocationCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// PropertyRequest

// optional string entity_name = 1;
inline bool PropertyRequest::has_entity_name() const {
  return identifier_case() == kEntityName;
}
inline void PropertyRequest::set_has_entity_name() {
  _oneof_case_[0] = kEntityName;
}
inline void PropertyRequest::clear_entity_name() {
  if (has_entity_name()) {
    delete identifier_.entity_name_;
    clear_has_identifier();
  }
}
inline const ::std::string& PropertyRequest::entity_name() const {
  if (has_entity_name()) {
    return *identifier_.entity_name_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void PropertyRequest::set_entity_name(const ::std::string& value) {
  if (!has_entity_name()) {
    clear_identifier();
    set_has_entity_name();
    identifier_.entity_name_ = new ::std::string;
  }
  identifier_.entity_name_->assign(value);
}
inline void PropertyRequest::set_entity_name(const char* value) {
  if (!has_entity_name()) {
    clear_identifier();
    set_has_entity_name();
    identifier_.entity_name_ = new ::std::string;
  }
  identifier_.entity_name_->assign(value);
}
inline void PropertyRequest::set_entity_name(const char* value, size_t size) {
  if (!has_entity_name()) {
    clear_identifier();
    set_has_entity_name();
    identifier_.entity_name_ = new ::std::string;
  }
  identifier_.entity_name_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PropertyRequest::mutable_entity_name() {
  if (!has_entity_name()) {
    clear_identifier();
    set_has_entity_name();
    identifier_.entity_name_ = new ::std::string;
  }
  return identifier_.entity_name_;
}
inline ::std::string* PropertyRequest::release_entity_name() {
  if (has_entity_name()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.entity_name_;
    identifier_.entity_name_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PropertyRequest::set_allocated_entity_name(::std::string* entity_name) {
  clear_identifier();
  if (entity_name) {
    set_has_entity_name();
    identifier_.entity_name_ = entity_name;
  }
}

// optional string entity_guid = 2;
inline bool PropertyRequest::has_entity_guid() const {
  return identifier_case() == kEntityGuid;
}
inline void PropertyRequest::set_has_entity_guid() {
  _oneof_case_[0] = kEntityGuid;
}
inline void PropertyRequest::clear_entity_guid() {
  if (has_entity_guid()) {
    delete identifier_.entity_guid_;
    clear_has_identifier();
  }
}
inline const ::std::string& PropertyRequest::entity_guid() const {
  if (has_entity_guid()) {
    return *identifier_.entity_guid_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void PropertyRequest::set_entity_guid(const ::std::string& value) {
  if (!has_entity_guid()) {
    clear_identifier();
    set_has_entity_guid();
    identifier_.entity_guid_ = new ::std::string;
  }
  identifier_.entity_guid_->assign(value);
}
inline void PropertyRequest::set_entity_guid(const char* value) {
  if (!has_entity_guid()) {
    clear_identifier();
    set_has_entity_guid();
    identifier_.entity_guid_ = new ::std::string;
  }
  identifier_.entity_guid_->assign(value);
}
inline void PropertyRequest::set_entity_guid(const char* value, size_t size) {
  if (!has_entity_guid()) {
    clear_identifier();
    set_has_entity_guid();
    identifier_.entity_guid_ = new ::std::string;
  }
  identifier_.entity_guid_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PropertyRequest::mutable_entity_guid() {
  if (!has_entity_guid()) {
    clear_identifier();
    set_has_entity_guid();
    identifier_.entity_guid_ = new ::std::string;
  }
  return identifier_.entity_guid_;
}
inline ::std::string* PropertyRequest::release_entity_guid() {
  if (has_entity_guid()) {
    clear_has_identifier();
    ::std::string* temp = identifier_.entity_guid_;
    identifier_.entity_guid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PropertyRequest::set_allocated_entity_guid(::std::string* entity_guid) {
  clear_identifier();
  if (entity_guid) {
    set_has_entity_guid();
    identifier_.entity_guid_ = entity_guid;
  }
}

// repeated .g3rc.PropertyIdentifier properties_get = 3;
inline int PropertyRequest::properties_get_size() const {
  return properties_get_.size();
}
inline void PropertyRequest::clear_properties_get() {
  properties_get_.Clear();
}
inline const ::g3rc::PropertyIdentifier& PropertyRequest::properties_get(int index) const {
  // @@protoc_insertion_point(field_get:g3rc.PropertyRequest.properties_get)
  return properties_get_.Get(index);
}
inline ::g3rc::PropertyIdentifier* PropertyRequest::mutable_properties_get(int index) {
  // @@protoc_insertion_point(field_mutable:g3rc.PropertyRequest.properties_get)
  return properties_get_.Mutable(index);
}
inline ::g3rc::PropertyIdentifier* PropertyRequest::add_properties_get() {
  // @@protoc_insertion_point(field_add:g3rc.PropertyRequest.properties_get)
  return properties_get_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertyIdentifier >&
PropertyRequest::properties_get() const {
  // @@protoc_insertion_point(field_list:g3rc.PropertyRequest.properties_get)
  return properties_get_;
}
inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertyIdentifier >*
PropertyRequest::mutable_properties_get() {
  // @@protoc_insertion_point(field_mutable_list:g3rc.PropertyRequest.properties_get)
  return &properties_get_;
}

// repeated .g3rc.PropertySerialized properties_set = 4;
inline int PropertyRequest::properties_set_size() const {
  return properties_set_.size();
}
inline void PropertyRequest::clear_properties_set() {
  properties_set_.Clear();
}
inline const ::g3rc::PropertySerialized& PropertyRequest::properties_set(int index) const {
  // @@protoc_insertion_point(field_get:g3rc.PropertyRequest.properties_set)
  return properties_set_.Get(index);
}
inline ::g3rc::PropertySerialized* PropertyRequest::mutable_properties_set(int index) {
  // @@protoc_insertion_point(field_mutable:g3rc.PropertyRequest.properties_set)
  return properties_set_.Mutable(index);
}
inline ::g3rc::PropertySerialized* PropertyRequest::add_properties_set() {
  // @@protoc_insertion_point(field_add:g3rc.PropertyRequest.properties_set)
  return properties_set_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >&
PropertyRequest::properties_set() const {
  // @@protoc_insertion_point(field_list:g3rc.PropertyRequest.properties_set)
  return properties_set_;
}
inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >*
PropertyRequest::mutable_properties_set() {
  // @@protoc_insertion_point(field_mutable_list:g3rc.PropertyRequest.properties_set)
  return &properties_set_;
}

inline bool PropertyRequest::has_identifier() {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void PropertyRequest::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline PropertyRequest::IdentifierCase PropertyRequest::identifier_case() const {
  return PropertyRequest::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HearbeatResponse

// required .g3rc.HearbeatResponse.Status status = 1;
inline bool HearbeatResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HearbeatResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HearbeatResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HearbeatResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::g3rc::HearbeatResponse_Status HearbeatResponse::status() const {
  // @@protoc_insertion_point(field_get:g3rc.HearbeatResponse.status)
  return static_cast< ::g3rc::HearbeatResponse_Status >(status_);
}
inline void HearbeatResponse::set_status(::g3rc::HearbeatResponse_Status value) {
  assert(::g3rc::HearbeatResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:g3rc.HearbeatResponse.status)
}

// -------------------------------------------------------------------

// VoidResponse

// -------------------------------------------------------------------

// EntityResponse

// required .g3rc.Position position = 1;
inline bool EntityResponse::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityResponse::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityResponse::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityResponse::clear_position() {
  if (position_ != NULL) position_->::g3rc::Position::Clear();
  clear_has_position();
}
inline const ::g3rc::Position& EntityResponse::position() const {
  // @@protoc_insertion_point(field_get:g3rc.EntityResponse.position)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return position_ != NULL ? *position_ : *default_instance().position_;
#else
  return position_ != NULL ? *position_ : *default_instance_->position_;
#endif
}
inline ::g3rc::Position* EntityResponse::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::g3rc::Position;
  // @@protoc_insertion_point(field_mutable:g3rc.EntityResponse.position)
  return position_;
}
inline ::g3rc::Position* EntityResponse::release_position() {
  clear_has_position();
  ::g3rc::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void EntityResponse::set_allocated_position(::g3rc::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.EntityResponse.position)
}

// required string name = 2;
inline bool EntityResponse::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityResponse::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EntityResponse::name() const {
  // @@protoc_insertion_point(field_get:g3rc.EntityResponse.name)
  return *name_;
}
inline void EntityResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:g3rc.EntityResponse.name)
}
inline void EntityResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:g3rc.EntityResponse.name)
}
inline void EntityResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:g3rc.EntityResponse.name)
}
inline ::std::string* EntityResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:g3rc.EntityResponse.name)
  return name_;
}
inline ::std::string* EntityResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EntityResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.EntityResponse.name)
}

// required string guid = 3;
inline bool EntityResponse::has_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntityResponse::set_has_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntityResponse::clear_has_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntityResponse::clear_guid() {
  if (guid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& EntityResponse::guid() const {
  // @@protoc_insertion_point(field_get:g3rc.EntityResponse.guid)
  return *guid_;
}
inline void EntityResponse::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
  // @@protoc_insertion_point(field_set:g3rc.EntityResponse.guid)
}
inline void EntityResponse::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
  // @@protoc_insertion_point(field_set_char:g3rc.EntityResponse.guid)
}
inline void EntityResponse::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:g3rc.EntityResponse.guid)
}
inline ::std::string* EntityResponse::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:g3rc.EntityResponse.guid)
  return guid_;
}
inline ::std::string* EntityResponse::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EntityResponse::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.EntityResponse.guid)
}

// -------------------------------------------------------------------

// PropertyResponse

// repeated .g3rc.PropertySerialized properties_get = 1;
inline int PropertyResponse::properties_get_size() const {
  return properties_get_.size();
}
inline void PropertyResponse::clear_properties_get() {
  properties_get_.Clear();
}
inline const ::g3rc::PropertySerialized& PropertyResponse::properties_get(int index) const {
  // @@protoc_insertion_point(field_get:g3rc.PropertyResponse.properties_get)
  return properties_get_.Get(index);
}
inline ::g3rc::PropertySerialized* PropertyResponse::mutable_properties_get(int index) {
  // @@protoc_insertion_point(field_mutable:g3rc.PropertyResponse.properties_get)
  return properties_get_.Mutable(index);
}
inline ::g3rc::PropertySerialized* PropertyResponse::add_properties_get() {
  // @@protoc_insertion_point(field_add:g3rc.PropertyResponse.properties_get)
  return properties_get_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >&
PropertyResponse::properties_get() const {
  // @@protoc_insertion_point(field_list:g3rc.PropertyResponse.properties_get)
  return properties_get_;
}
inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >*
PropertyResponse::mutable_properties_get() {
  // @@protoc_insertion_point(field_mutable_list:g3rc.PropertyResponse.properties_get)
  return &properties_get_;
}

// repeated .g3rc.PropertySerialized properties_set = 2;
inline int PropertyResponse::properties_set_size() const {
  return properties_set_.size();
}
inline void PropertyResponse::clear_properties_set() {
  properties_set_.Clear();
}
inline const ::g3rc::PropertySerialized& PropertyResponse::properties_set(int index) const {
  // @@protoc_insertion_point(field_get:g3rc.PropertyResponse.properties_set)
  return properties_set_.Get(index);
}
inline ::g3rc::PropertySerialized* PropertyResponse::mutable_properties_set(int index) {
  // @@protoc_insertion_point(field_mutable:g3rc.PropertyResponse.properties_set)
  return properties_set_.Mutable(index);
}
inline ::g3rc::PropertySerialized* PropertyResponse::add_properties_set() {
  // @@protoc_insertion_point(field_add:g3rc.PropertyResponse.properties_set)
  return properties_set_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >&
PropertyResponse::properties_set() const {
  // @@protoc_insertion_point(field_list:g3rc.PropertyResponse.properties_set)
  return properties_set_;
}
inline ::google::protobuf::RepeatedPtrField< ::g3rc::PropertySerialized >*
PropertyResponse::mutable_properties_set() {
  // @@protoc_insertion_point(field_mutable_list:g3rc.PropertyResponse.properties_set)
  return &properties_set_;
}

// -------------------------------------------------------------------

// Position

// required .g3rc.Vector translation = 1;
inline bool Position::has_translation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_translation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_translation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_translation() {
  if (translation_ != NULL) translation_->::g3rc::Vector::Clear();
  clear_has_translation();
}
inline const ::g3rc::Vector& Position::translation() const {
  // @@protoc_insertion_point(field_get:g3rc.Position.translation)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return translation_ != NULL ? *translation_ : *default_instance().translation_;
#else
  return translation_ != NULL ? *translation_ : *default_instance_->translation_;
#endif
}
inline ::g3rc::Vector* Position::mutable_translation() {
  set_has_translation();
  if (translation_ == NULL) translation_ = new ::g3rc::Vector;
  // @@protoc_insertion_point(field_mutable:g3rc.Position.translation)
  return translation_;
}
inline ::g3rc::Vector* Position::release_translation() {
  clear_has_translation();
  ::g3rc::Vector* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Position::set_allocated_translation(::g3rc::Vector* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    set_has_translation();
  } else {
    clear_has_translation();
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.Position.translation)
}

// required .g3rc.Vector scale = 2;
inline bool Position::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_scale() {
  if (scale_ != NULL) scale_->::g3rc::Vector::Clear();
  clear_has_scale();
}
inline const ::g3rc::Vector& Position::scale() const {
  // @@protoc_insertion_point(field_get:g3rc.Position.scale)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scale_ != NULL ? *scale_ : *default_instance().scale_;
#else
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
#endif
}
inline ::g3rc::Vector* Position::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::g3rc::Vector;
  // @@protoc_insertion_point(field_mutable:g3rc.Position.scale)
  return scale_;
}
inline ::g3rc::Vector* Position::release_scale() {
  clear_has_scale();
  ::g3rc::Vector* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Position::set_allocated_scale(::g3rc::Vector* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.Position.scale)
}

// required .g3rc.EulerAngles rotation = 3;
inline bool Position::has_rotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_rotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_rotation() {
  if (rotation_ != NULL) rotation_->::g3rc::EulerAngles::Clear();
  clear_has_rotation();
}
inline const ::g3rc::EulerAngles& Position::rotation() const {
  // @@protoc_insertion_point(field_get:g3rc.Position.rotation)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rotation_ != NULL ? *rotation_ : *default_instance().rotation_;
#else
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
#endif
}
inline ::g3rc::EulerAngles* Position::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::g3rc::EulerAngles;
  // @@protoc_insertion_point(field_mutable:g3rc.Position.rotation)
  return rotation_;
}
inline ::g3rc::EulerAngles* Position::release_rotation() {
  clear_has_rotation();
  ::g3rc::EulerAngles* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void Position::set_allocated_rotation(::g3rc::EulerAngles* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.Position.rotation)
}

// -------------------------------------------------------------------

// Vector

// required float x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:g3rc.Vector.x)
  return x_;
}
inline void Vector::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:g3rc.Vector.x)
}

// required float y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:g3rc.Vector.y)
  return y_;
}
inline void Vector::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:g3rc.Vector.y)
}

// required float z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:g3rc.Vector.z)
  return z_;
}
inline void Vector::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:g3rc.Vector.z)
}

// -------------------------------------------------------------------

// EulerAngles

// required float yaw = 1;
inline bool EulerAngles::has_yaw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EulerAngles::set_has_yaw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EulerAngles::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EulerAngles::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float EulerAngles::yaw() const {
  // @@protoc_insertion_point(field_get:g3rc.EulerAngles.yaw)
  return yaw_;
}
inline void EulerAngles::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:g3rc.EulerAngles.yaw)
}

// required float pitch = 2;
inline bool EulerAngles::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EulerAngles::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EulerAngles::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EulerAngles::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float EulerAngles::pitch() const {
  // @@protoc_insertion_point(field_get:g3rc.EulerAngles.pitch)
  return pitch_;
}
inline void EulerAngles::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:g3rc.EulerAngles.pitch)
}

// required float roll = 3;
inline bool EulerAngles::has_roll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EulerAngles::set_has_roll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EulerAngles::clear_has_roll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EulerAngles::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float EulerAngles::roll() const {
  // @@protoc_insertion_point(field_get:g3rc.EulerAngles.roll)
  return roll_;
}
inline void EulerAngles::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:g3rc.EulerAngles.roll)
}

// -------------------------------------------------------------------

// PropertyIdentifier

// optional string property_set = 1;
inline bool PropertyIdentifier::has_property_set() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyIdentifier::set_has_property_set() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyIdentifier::clear_has_property_set() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyIdentifier::clear_property_set() {
  if (property_set_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_set_->clear();
  }
  clear_has_property_set();
}
inline const ::std::string& PropertyIdentifier::property_set() const {
  // @@protoc_insertion_point(field_get:g3rc.PropertyIdentifier.property_set)
  return *property_set_;
}
inline void PropertyIdentifier::set_property_set(const ::std::string& value) {
  set_has_property_set();
  if (property_set_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_set_ = new ::std::string;
  }
  property_set_->assign(value);
  // @@protoc_insertion_point(field_set:g3rc.PropertyIdentifier.property_set)
}
inline void PropertyIdentifier::set_property_set(const char* value) {
  set_has_property_set();
  if (property_set_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_set_ = new ::std::string;
  }
  property_set_->assign(value);
  // @@protoc_insertion_point(field_set_char:g3rc.PropertyIdentifier.property_set)
}
inline void PropertyIdentifier::set_property_set(const char* value, size_t size) {
  set_has_property_set();
  if (property_set_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_set_ = new ::std::string;
  }
  property_set_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:g3rc.PropertyIdentifier.property_set)
}
inline ::std::string* PropertyIdentifier::mutable_property_set() {
  set_has_property_set();
  if (property_set_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_set_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:g3rc.PropertyIdentifier.property_set)
  return property_set_;
}
inline ::std::string* PropertyIdentifier::release_property_set() {
  clear_has_property_set();
  if (property_set_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = property_set_;
    property_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PropertyIdentifier::set_allocated_property_set(::std::string* property_set) {
  if (property_set_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete property_set_;
  }
  if (property_set) {
    set_has_property_set();
    property_set_ = property_set;
  } else {
    clear_has_property_set();
    property_set_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.PropertyIdentifier.property_set)
}

// optional string property = 2;
inline bool PropertyIdentifier::has_property() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyIdentifier::set_has_property() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyIdentifier::clear_has_property() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyIdentifier::clear_property() {
  if (property_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_->clear();
  }
  clear_has_property();
}
inline const ::std::string& PropertyIdentifier::property() const {
  // @@protoc_insertion_point(field_get:g3rc.PropertyIdentifier.property)
  return *property_;
}
inline void PropertyIdentifier::set_property(const ::std::string& value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_ = new ::std::string;
  }
  property_->assign(value);
  // @@protoc_insertion_point(field_set:g3rc.PropertyIdentifier.property)
}
inline void PropertyIdentifier::set_property(const char* value) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_ = new ::std::string;
  }
  property_->assign(value);
  // @@protoc_insertion_point(field_set_char:g3rc.PropertyIdentifier.property)
}
inline void PropertyIdentifier::set_property(const char* value, size_t size) {
  set_has_property();
  if (property_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_ = new ::std::string;
  }
  property_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:g3rc.PropertyIdentifier.property)
}
inline ::std::string* PropertyIdentifier::mutable_property() {
  set_has_property();
  if (property_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    property_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:g3rc.PropertyIdentifier.property)
  return property_;
}
inline ::std::string* PropertyIdentifier::release_property() {
  clear_has_property();
  if (property_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = property_;
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PropertyIdentifier::set_allocated_property(::std::string* property) {
  if (property_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete property_;
  }
  if (property) {
    set_has_property();
    property_ = property;
  } else {
    clear_has_property();
    property_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.PropertyIdentifier.property)
}

// -------------------------------------------------------------------

// PropertySerialized

// required .g3rc.PropertyIdentifier identifier = 1;
inline bool PropertySerialized::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertySerialized::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertySerialized::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertySerialized::clear_identifier() {
  if (identifier_ != NULL) identifier_->::g3rc::PropertyIdentifier::Clear();
  clear_has_identifier();
}
inline const ::g3rc::PropertyIdentifier& PropertySerialized::identifier() const {
  // @@protoc_insertion_point(field_get:g3rc.PropertySerialized.identifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return identifier_ != NULL ? *identifier_ : *default_instance().identifier_;
#else
  return identifier_ != NULL ? *identifier_ : *default_instance_->identifier_;
#endif
}
inline ::g3rc::PropertyIdentifier* PropertySerialized::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) identifier_ = new ::g3rc::PropertyIdentifier;
  // @@protoc_insertion_point(field_mutable:g3rc.PropertySerialized.identifier)
  return identifier_;
}
inline ::g3rc::PropertyIdentifier* PropertySerialized::release_identifier() {
  clear_has_identifier();
  ::g3rc::PropertyIdentifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline void PropertySerialized::set_allocated_identifier(::g3rc::PropertyIdentifier* identifier) {
  delete identifier_;
  identifier_ = identifier;
  if (identifier) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.PropertySerialized.identifier)
}

// optional bytes data = 2;
inline bool PropertySerialized::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertySerialized::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertySerialized::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertySerialized::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PropertySerialized::data() const {
  // @@protoc_insertion_point(field_get:g3rc.PropertySerialized.data)
  return *data_;
}
inline void PropertySerialized::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:g3rc.PropertySerialized.data)
}
inline void PropertySerialized::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:g3rc.PropertySerialized.data)
}
inline void PropertySerialized::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:g3rc.PropertySerialized.data)
}
inline ::std::string* PropertySerialized::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:g3rc.PropertySerialized.data)
  return data_;
}
inline ::std::string* PropertySerialized::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PropertySerialized::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:g3rc.PropertySerialized.data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace g3rc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_g3rc_2eproto__INCLUDED
